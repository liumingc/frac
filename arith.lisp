(defpackage :num
  (:use :cl)
  (:export num->int int->num num+ num-
           num-mul num-div num-mod num-div/mod
           normalize
           num< num=))

(in-package :num)
;; 123 repr as '(3 2 1)

(defun num->int (x)
  (labels ((f (x m result)
             (cond ((null x) result)
                   (t (f (cdr x)
                         (* m 10)
                         (+ result (* m (car x))))))))
    (f x 1 0)))

(defun int->num (i)
  (labels ((f (i result)
             (cond ((zerop i) (reverse result))
                   (t (multiple-value-bind (q r)
                          (floor i 10)
                        (f q (cons r result)))))))
    (let ((result (f i nil)))
      (if (null result)
          '(0)
          result))))

(defun num+ (x1 x2)
  (labels ((f (x1 x2 carry)
             (cond ((and (null x1) (null x2))
                    (if (zerop carry) nil (cons carry nil)))
                   ((null x1)
                    (f1 carry x2))
                   ((null x2)
                    (f1 carry x1))
                   (t (multiple-value-bind (c q)
                          (floor (+ carry (car x1) (car x2)) 10)
                        (cons q (f (cdr x1) (cdr x2) c))))))
           (f1 (carry x1)
             (if (zerop carry)
                 (copy-seq x1)
                 (if (null x1)
                     (cons carry nil)
                     (multiple-value-bind (c q)
                         (floor (+ carry (car x1)) 10)
                       (cons q (f1 c (cdr x1))))))))
    (f x1 x2 0)))

(defun num= (x1 x2)
  (let ((n1 (length x1))
        (n2 (length x2)))
    (if (= n1 n2)
        (labels ((f (x1 x2)
                   (cond ((null x1) t)
                         ((= (car x1) (car x2))
                          (f (cdr x1) (cdr x2)))
                         (t nil))))
          (f x1 x2))
        nil)))


(defun num< (x1 x2)
  (let ((n1 (length x1))
        (n2 (length x2)))
    (cond ((< n1 n2) t)
          ((< n2 n1) nil)
          (t (labels ((f (x1 x2)
                        (cond ((null x1) t)
                              ((num= (cdr x2) (cdr x1))
                               (< (car x1) (car x2)))
                              ((num< (cdr x1) (cdr x2)) t)
                              (t
                               nil))))
               (f x1 x2))))))


(defun num- (x1 x2)
  (if (num< x1 x2)
      (num- x2 x1) ;; to make life easier. maybe add some sign field to a struct in the future.
      (labels ((acchi (x hi) ;; accumulate high
                 (if (and (null (cdr hi))
                          (eql (car hi) 0))
                     (cons x nil)
                     (cons x hi)))
               (f (x1 x2 borrow)
                 (cond ((null x1) nil)
                       ((null x2)
                        (let* ((x (- (car x1) borrow))
                               (b (if (< (car x1) borrow) 1 0)))
                          (acchi (if (< x 0) (+ x 10) x)
                                 (f (cdr x1) nil b))))
                       (t (let ((h1 (car x1)) (h2 (+ borrow (car x2))))
                            (if (< h1 h2)
                                (acchi (- (+ h1 10) h2) (f (cdr x1) (cdr x2) 1))
                                (acchi (- h1 h2) (f (cdr x1) (cdr x2) 0))))))))
        (f x1 x2 0))))

;; used in num-mul & num-div
(defun %multi (x i carry)
  (cond ((null x)
         (if (zerop carry)
             nil
             (int->num carry)))
        ((eql i 1) (copy-seq x))
        ((eql i 0) '(0))
        (t (let* ((h (car x))
                  (v (+ (* h i) carry)))
             (multiple-value-bind (c r)
                 (floor v 10)
               (cons r (%multi (cdr x) i c)))))))

;; to trim the preceding 0's.
(defun normalize (x)
                                        ;(int->num (num->int x))
  (labels ((f (x)
             (cond ((null (cdr x))
                    (if (eql (car x) 0)
                        nil
                        x))
                   (t (let ((tl (f (cdr x))))
                        (if (null tl) ;(equal tl '(0))
                            (if (eql (car x) 0)
                                nil
                                (cons (car x) nil))
                            (cons (car x) tl)))))))
    (let ((result (f x)))
      (if (null result) '(0) result))))

(defun num-mul (x1 x2)
  (labels ((mul10 (x)
             (cond ((equal x '(0)) '(0))
                   (t (cons 0 x))))
           (f (x1 x2)
             (cond ((null x2) '(0))
                   (t (let* ((hi (f x1 (cdr x2)))
                             (hi0 (mul10 hi))
                             (lo (%multi x1 (car x2) 0)))
                        (num+ lo hi0))))))
    (cond ((or (equal x1 '(0)) (equal x2 '(0))) '(0))
          ((equal x2 '(1)) (copy-seq x1))
          ((equal x1 '(1)) (copy-seq x2))
          (t (f x1 x2)))))

;; ensure x1 > x2
(defun %dvmd (x1 x2)
  (let* ((n2 (length x2))
         (n1 (length x1))
         (n (- n1 n2))
         (q (subseq x1 n))
         (r (reverse (subseq x1 0 n))))
    (labels ((try-div (x1 x2 n)
               ;(format t "TRY-DIV ~a / ~a, n=~d~%" x1 x2 n)
               (cond ((num< x1 x2) (cons x1 n))
                     ((num= x1 x2) (cons '(0) (1+ n)))
                     (t (try-div (num- x1 x2) x2 (1+ n)))))
             (f (q r divres)
               #|(let ((res (try-div q x2 0)))
                 (format t "TRY-DIV ~d / ~d~%res=~a~%"
                         (num->int q) (num->int x2) res))|#
               (let* ((res (try-div q x2 0))
                      (q1 (cdr res))
                      (r1 (car res)))
                 (cond ((null r) (values (normalize (cons q1 divres)) r1))
                       (t (f (normalize (cons (car r) r1))
                             (cdr r)
                             (normalize (cons q1 divres))))))))
      ;(format t "DIV/MOD ~d / ~d~%" (num->int x1) (num->int x2))
      (f q r nil))))

(defun %div/mod (x1 x2)
  (cond ((num< x1 x2)
         (values '(0) (copy-seq x1)))
        ((num= x1 x2)
         (values '(1) '(0)))
        ((equal x2 '(0)) (values 'undef 'undef))
        (t (%dvmd x1 x2))))


(defun num-div/mod (x1 x2)
  (%div/mod x1 x2))

(defun num-div (x1 x2)
  (multiple-value-bind (q r)
      (num-div/mod x1 x2)
    (declare (ignore r))
    q))

(defun num-mod (x1 x2)
  (multiple-value-bind (q r)
      (num-div/mod x1 x2)
    (declare (ignore q))
    r))

;; num::foo
;; test num+, num<, num=
(defun foo ()
  (let ((xs '((123 4)
              (789 45)
              (3364 4527)
              (7891 4527)
              (7895 4527)
              (023 7896)
              (9997 9985)
              (9999 8)
              (23 24)
              (24 23)
              (28 57)
              (57 28)
              (1 4)
              (5 4)
              (3 4)
              (4 3)
              (535 1)
              (1 535)
              (535 0)
              (0 535)
              (10005 7)
              (20006 23)
              (30003 375)
              (123456789 987654321)
              (987654321 123456789)
              (987654321 234)
              (8 7777)
              (888 888)
              (077 77)
              (777 777))))
    (loop for x in xs
          do (let* ((i1 (car x))
                    (i2 (cadr x))
                    (x1 (int->num i1))
                    (x2 (int->num i2))
                    )
               (assert (= (+ i1 i2)
                          (num->int (num+ x1 x2))))
               (assert (eql (num< x1 x2) (< i1 i2)))
               (assert (eql (num= x1 x2) (= i1 i2)))
               (assert (eql (num->int (num- x1 x2)) (abs (- i1 i2))))
               (assert (eql (num->int (num-mul x1 x2)) (* i1 i2)))
               (unless (eql i2 0)
                 (multiple-value-bind (q r)
                     (%div/mod x1 x2)
                   (multiple-value-bind (iq ir)
                       (floor i1 i2)
                     (assert (and (eql (num->int q) iq)
                                  (eql (num->int r) ir)))
                     #|(format t "i1=~d, i2=~d~%q1=~d~%q2=~d~%r1=~d~%r2=~d~%"
                     i1 i2 iq (num->int q) ir (num->int r))|#
                     )))
               ))))
